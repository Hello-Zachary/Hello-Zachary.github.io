{"meta":{"title":"Zachary","subtitle":null,"description":"一个热爱生活的程序猿","author":"Zachary","url":"https://hello-zachary.github.io","root":"/"},"pages":[{"title":"","date":"2019-04-16T03:17:11.999Z","updated":"2019-04-16T03:17:05.193Z","comments":true,"path":"google405c9d658ad71e7f.html","permalink":"https://hello-zachary.github.io/google405c9d658ad71e7f.html","excerpt":"","text":"google-site-verification: google405c9d658ad71e7f.html"},{"title":"","date":"2019-04-15T08:52:02.514Z","updated":"2019-04-15T08:52:02.514Z","comments":true,"path":"about/index.html","permalink":"https://hello-zachary.github.io/about/index.html","excerpt":"","text":"关于我目前还是在校大学生，主要开发语言 PHP，熟悉使用 Laravel、ThinkPHP 等主流框架；对 Modern PHP 情有独钟；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：深圳 关于学习正在往终身学习者前进…近期学习方向：Python (人工智能) 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我 Blog: blog.hello-zachary.com Email: 1404139248@qq.com GitHub: Zachary WeiBo: Zachary"}],"posts":[{"title":"编译原理---FIRST集的求法","slug":"FIRST","date":"2019-04-19T16:00:00.000Z","updated":"2019-04-20T05:28:33.509Z","comments":true,"path":"2019/04/20/FIRST/","link":"","permalink":"https://hello-zachary.github.io/2019/04/20/FIRST/","excerpt":"","text":"编译原理—FIRST集的求法定义 设G=(VT，VN，S，P)是上下文无关文法 ，FIRST(α)={a|α能推导出aβ,a∈VT，α,β∈V*}特别的，若α能推导出ε,则规定ε∈FIRST(α)． 说得简单点就是一个文法符号串所能推导出的第一个终结字符的集合,如First(A)就是求A所有推导的符号串的第一个符号的集合。(这里默认大写字母为非终结字符，小写字母或符号为终结字符) 在这里我啰嗦一句，当我们在解决多数问题的时候，了解它的定义和原理是很关键的，这可以帮助我们有条不紊的将求解过程进行下去，毕竟透过本质看问题才看得更清楚嘛~ 常见情况 单个终结字符的FIRST集：它的FIRST集就是它本身，例FIRST(a)={a} ； 以终结字符开头，形如X-&gt;a…：a属于FIRST(X)； 以非终结字符开头，且这个非终结字符不能推出ε，形如X-&gt;A…：FIRST(X)=FIRST(X); 以非终结字符开头，且这个非终结字符能推出ε，形如X-&gt;ABC…（其中A能推导出ε，B不能推导出ε）：FIRST(X)=(FIRST(A)-{ε})∪FIRST(B)；那我们假如A能推导出ε，B能推导出ε，C不能推导出ε，则FIRST(X)=(FIRST(A)-{ε})∪(FIRST(B)-{ε})∪FIRST(C)； 以非终结字符开头，且这个非终结字符能推出ε，形如X-&gt;AbC…（其中A能推导出ε，C不能推导出ε）：FIRST(X)=FIRST(A)∪{b}； 产生式右部全为 非终结字符，且都能推出ε，形如X-&gt;ABCD(其中A，B，C，D都能推出ε)：FIRST(X)=(FIRST(A)-{ε})∪(FIRST(B)-{ε})∪(FIRST(C)-{ε})∪(FIRST(D)-{ε})∪{ε}； 例题1234567891011有文法G[S]：S-&gt;ABS-&gt;bCA-&gt;εA-&gt;bB-&gt;εB-&gt;aDC-&gt;ADC-&gt;bD-&gt;aSD-c 123456解：FIRST(S)=(FIRST(A)-&#123;ε&#125;)∪(FIRST(B)-&#123;ε&#125;)∪&#123;ε&#125;∪&#123;b&#125;=&#123;a,b,ε&#125;FIRST(A)=&#123;ε&#125;∪&#123;b&#125;=&#123;ε,b&#125;FIRST(B)=&#123;ε&#125;∪&#123;a&#125;=&#123;ε,a&#125;FIRST(C)=(FIRST(A)-&#123;ε&#125;)∪FIRST(D)=&#123;a,b,c&#125;FIRST(D)=&#123;a&#125;∪&#123;c&#125;=&#123;a,c&#125; 结语因为这几天在补编译原理，今天就先把有关FIRST集合的发出来，也为后面考试复习打好铺垫~","categories":[{"name":"编译原理FIRST集","slug":"编译原理FIRST集","permalink":"https://hello-zachary.github.io/categories/编译原理FIRST集/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://hello-zachary.github.io/tags/编译原理/"},{"name":"FIRST集","slug":"FIRST集","permalink":"https://hello-zachary.github.io/tags/FIRST集/"}],"author":"Zachary"},{"title":"微信小程序上拉更新数据","slug":"wechat","date":"2019-04-16T16:00:00.000Z","updated":"2019-04-17T15:20:19.685Z","comments":true,"path":"2019/04/17/wechat/","link":"","permalink":"https://hello-zachary.github.io/2019/04/17/wechat/","excerpt":"","text":"微信小程序上拉更新数据 今天在做小程序项目的时候发现需要用到上拉加载新数据的功能，其实这个功能实用性还蛮大的，所以呢，在这里记录一在小程序里下如何通过上拉加载加载更多数据。 我们先来看下小程序官方文档里关于页面上拉触底事件的介绍： 是不是有点迷糊，我第一次看的时候也是犯晕，不知道如何操作，谁叫自己菜呢！废话不多说，直接上个Demo吧！ 这里要说明一下，我的数据来源是从小程序的云数据库获取的 数据渲染 这个没什么讲的，就是把获取的数据渲染在页面上12345.wxml文件&lt;view wx:for=&quot;&#123;&#123;num&#125;&#125;&quot;&gt;&lt;view class=&apos;num&apos;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;&lt;/view&gt; 数据分页获取要实现上拉数据更新，那数据肯定要进行分页获取吧,这里涉及到小程序云数据库数据的分页获取。具体的用法咱接着往下看吧 获取数据代码1234567891011121314151617181920212223242526.js文件Page(&#123; data: &#123; num: [], //定义一个数组用于接收从数据库获取的数据 page: 0 &#125;, /** * 生命周期函数--监听页面加载 * 在页面载入的时候执行一次查询 */ onLoad: function(options) &#123; var that = this wx.cloud.init(); const db = wx.cloud.database(); const Test = db.collection(&apos;Test&apos;); Test.where(&#123;&#125;).limit(5).get(&#123; //limit(5):每次获取5个数据 success(res) &#123; that.setData(&#123; //将获取的数据存入data里的num数组中 num: res.data &#125;) &#125; &#125;) &#125;, skip(number):从第number+1个数据开始加载后面的数据，因为在页面刚被加载的时候,已经加载了5条数据，上拉的时候应该从第6条数据开始加载,所以这里是skip(this.data.page*5) 12345678910111213141516171819202122232425262728293031/** * 定义一个获取数据的函数 */ getNum: function() &#123; var that = this wx.cloud.init(); const db = wx.cloud.database(); const Test = db.collection(&apos;Test&apos;); Test.where(&#123;&#125;).skip(this.data.page * 5).limit(5).get(&#123; success(res) &#123; console.log(res) var arr = res.data that.setData(&#123; num: that.data.num.concat(arr) &#125;) &#125; &#125;) &#125;,/** * 页面上拉触底事件的处理函数 */ onReachBottom: function() &#123; this.setData(&#123; /**前面在页面刚载入的时候已经加载了5条数据（也就是一页）， * 所以当页面上拉事件触发的时候,开始加载第二页的数据，故page得+1 */ page: this.data.page + 1 &#125;) this.getNum(); &#125;,&#125;) 如果想要实现无感加载，还可以在.json文件中给onReachBottom()设定合适的触发距离，这样不用拉到最底部才开始触发","categories":[{"name":"微信小程序上拉更新数据","slug":"微信小程序上拉更新数据","permalink":"https://hello-zachary.github.io/categories/微信小程序上拉更新数据/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://hello-zachary.github.io/tags/微信小程序/"},{"name":"上拉更新数据","slug":"上拉更新数据","permalink":"https://hello-zachary.github.io/tags/上拉更新数据/"}],"author":"Zachary"},{"title":"Hexo文件目录结构","slug":"hexoFile","date":"2019-04-14T16:00:00.000Z","updated":"2019-04-15T08:44:51.443Z","comments":true,"path":"2019/04/15/hexoFile/","link":"","permalink":"https://hello-zachary.github.io/2019/04/15/hexoFile/","excerpt":"","text":"Hexo文件目录结构 捣鼓了大半天，终于算是搭好了自己的第一个博客，下面来整理一下Hexo的目录结构，了解Hexo目录下每个文件的作用。 下面的截图是我的博客空间文件目录： 现在让我们来看看各个文件的用途 node_modules1这个文件夹 是nodejs库文件目录，也就是我们通过&quot;npm install&quot;命令安装的文件位置 scaffolds1翻译过来是 &quot;脚手架&quot; 的意思，这里引申为模板文件夹。当我们通过&quot; hexo new &lt;layout(布局)&gt; &lt;title&gt;&quot; 命令创建一篇文章的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。 public1参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用 hexo clean 清除 db.json 和 public 文件夹下的所有文件。 source1这个文件夹存储一些直接来自用户的文件,它是我们主要工作的地方,如果不出意外我们的文章就是保存在这个文件夹下（_posts）。其中，_posts 文件是写文章地方，而除了 _posts 文件夹之外,以_(下划线)命名开头的文件或文件夹和隐藏的文件将会被忽略。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。 themes1主题文件夹，存储主题。我们可以在 Github 上免费下载自己喜欢的主题文件存放在这文件夹内。 npmignore1记录了不需要上传到npm的文件。 _config.yml1网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。 db.json1里面存放了一些由source目录下.md 的所有文件解析得到的数据 debug.log1这个文件记录了我们在 debug 模式下的消息详情。 package.json1框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 --save 保存进去。 package-lock.json1锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致。 好了，以上就是Hexo博客目录下的文件结构及其作用了。","categories":[{"name":"文件作用","slug":"文件作用","permalink":"https://hello-zachary.github.io/categories/文件作用/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hello-zachary.github.io/tags/Hexo/"},{"name":"目录结构","slug":"目录结构","permalink":"https://hello-zachary.github.io/tags/目录结构/"},{"name":"作用","slug":"作用","permalink":"https://hello-zachary.github.io/tags/作用/"}],"author":"Zachary"}]}